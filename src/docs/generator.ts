/**
 * Documentation Auto-generation System
 * Parses TypeScript schemas and Zod definitions to generate Markdown docs
 *
 * Author: Bogdan Marcen & ChatGPT 5.1
 */

import * as fs from "fs/promises";
import * as path from "path";
import { z } from "zod";
import * as Handlebars from "handlebars";
import { ToolSchema } from "../core/tool-engine/toolSchema";

export interface DocGeneratorOptions {
  /** Output directory for generated docs */
  outputDir: string;
  /** Templates directory */
  templatesDir?: string;
  /** Whether to include examples */
  includeExamples?: boolean;
  /** Custom templates */
  templates?: Record<string, string>;
}

export class DocGenerator {
  private options: Required<DocGeneratorOptions>;
  private templates: Map<string, HandlebarsTemplateDelegate> = new Map();

  constructor(options: DocGeneratorOptions) {
    this.options = {
      outputDir: options.outputDir,
      templatesDir: options.templatesDir || path.join(__dirname, "templates"),
      includeExamples: options.includeExamples ?? true,
      templates: options.templates || {},
    };

    this.loadTemplates();
  }

  /**
   * Generate documentation for tools
   */
  async generateToolsDocs(tools: ToolSchema[]): Promise<void> {
    console.log(`üìù Generating documentation for ${tools.length} tools...`);

    // Ensure output directories exist
    await fs.mkdir(this.options.outputDir, { recursive: true });
    await fs.mkdir(path.join(this.options.outputDir, "tools"), { recursive: true });

    // Generate individual tool docs
    for (const tool of tools) {
      const docContent = this.generateToolDoc(tool);
      const filename = `${tool.name}.md`;
      const filepath = path.join(this.options.outputDir, "tools", filename);

      await fs.writeFile(filepath, docContent);
      console.log(`   ‚úì ${tool.name} ‚Üí ${filepath}`);
    }

    // Generate tools index
    const indexContent = this.generateToolsIndex(tools);
    const indexPath = path.join(this.options.outputDir, "tools.md");
    await fs.writeFile(indexPath, indexContent);
    console.log(`   ‚úì tools.md ‚Üí ${indexPath}`);
  }

  /**
   * Generate documentation for models
   */
  async generateModelsDocs(models: ModelInfo[]): Promise<void> {
    console.log(`ü§ñ Generating documentation for ${models.length} models...`);

    const docContent = this.generateModelsDoc(models);
    const filepath = path.join(this.options.outputDir, "models.md");

    await fs.writeFile(filepath, docContent);
    console.log(`   ‚úì models.md ‚Üí ${filepath}`);
  }

  /**
   * Generate CLI documentation
   */
  async generateCliDocs(commands: CliCommand[]): Promise<void> {
    console.log(`üíª Generating CLI documentation...`);

    const docContent = this.generateCliDoc(commands);
    const filepath = path.join(this.options.outputDir, "cli.md");

    await fs.writeFile(filepath, docContent);
    console.log(`   ‚úì cli.md ‚Üí ${filepath}`);
  }

  /**
   * Generate README for the entire docs
   */
  async generateReadme(): Promise<void> {
    const readmeContent = `# Arium Documentation

This documentation is automatically generated from the codebase.

## Sections

- [Tools](./tools.md) - Available tools and their schemas
- [Models](./models.md) - Supported AI models and configurations
- [CLI](./cli.md) - Command-line interface reference
- [Architecture](./architecture.md) - System architecture overview

## API Reference

- [Core Systems](./core-systems.md) - EventBus, VFS, Tool Engine
- [Agent Core](./agent-core.md) - Agent execution and reasoning
- [Security](./security.md) - Permission system and sandboxing

---

*Generated by Arium Docs Generator*
`;

    const filepath = path.join(this.options.outputDir, "README.md");
    await fs.writeFile(filepath, readmeContent);
    console.log(`   ‚úì README.md ‚Üí ${filepath}`);
  }

  private generateToolDoc(tool: ToolSchema): string {
    const template = this.templates.get("tool") || this.getDefaultToolTemplate();

    const context = {
      name: tool.name,
      description: tool.description,
      inputSchema: this.formatZodSchema(tool.input),
      outputSchema: this.formatZodSchema(tool.output),
      permissions: tool.permissions,
      examples: this.options.includeExamples ? this.generateExamples(tool) : [],
    };

    return template(context);
  }

  private generateToolsIndex(tools: ToolSchema[]): string {
    const template = this.templates.get("tools-index") || this.getDefaultToolsIndexTemplate();

    const toolList = tools.map(tool => ({
      name: tool.name,
      description: tool.description,
      permissions: tool.permissions,
    }));

    return template({ tools: toolList });
  }

  private generateModelsDoc(models: ModelInfo[]): string {
    const template = this.templates.get("models") || this.getDefaultModelsTemplate();
    return template({ models });
  }

  private generateCliDoc(commands: CliCommand[]): string {
    const template = this.templates.get("cli") || this.getDefaultCliTemplate();
    return template({ commands });
  }

  private formatZodSchema(schema: z.ZodSchema): SchemaField[] {
    try {
      // This is a simplified schema parser
      // In a real implementation, you'd use a proper Zod schema analyzer
      return this.extractSchemaFields(schema);
    } catch (error) {
      return [{ field: "schema", type: "unknown", required: true, description: "Schema parsing failed" }];
    }
  }

  private extractSchemaFields(schema: z.ZodSchema): SchemaField[] {
    // Simplified schema field extraction
    // This would need to be enhanced for complex schemas
    const fields: SchemaField[] = [];

    if (schema instanceof z.ZodObject) {
      const shape = (schema as any)._def.shape();
      for (const [key, fieldSchema] of Object.entries(shape)) {
        const field = fieldSchema as z.ZodSchema;
        const isOptional = field instanceof z.ZodOptional;
        const actualSchema = isOptional ? field._def.innerType : field;

        fields.push({
          field: key,
          type: this.getSchemaType(actualSchema),
          required: !isOptional,
          description: this.getSchemaDescription(actualSchema),
        });
      }
    }

    return fields;
  }

  private getSchemaType(schema: z.ZodSchema): string {
    if (schema instanceof z.ZodString) return "string";
    if (schema instanceof z.ZodNumber) return "number";
    if (schema instanceof z.ZodBoolean) return "boolean";
    if (schema instanceof z.ZodArray) return "array";
    if (schema instanceof z.ZodObject) return "object";
    return "unknown";
  }

  private getSchemaDescription(schema: z.ZodSchema): string {
    // Try to extract description from schema
    const def = (schema as any)._def;
    return def.description || "";
  }

  private generateExamples(tool: ToolSchema): string[] {
    // Generate example usage based on schema
    const examples: string[] = [];

    try {
      // This would generate examples based on the schema
      // For now, just return a placeholder
      examples.push(`// Example usage for ${tool.name}\n// TODO: Generate from schema`);
    } catch (error) {
      examples.push("// Example generation failed");
    }

    return examples;
  }

  private loadTemplates(): void {
    // Load custom templates if provided
    for (const [name, content] of Object.entries(this.options.templates)) {
      this.templates.set(name, Handlebars.compile(content));
    }

    // Register default templates
    this.templates.set("tool", Handlebars.compile(this.getDefaultToolTemplate()));
    this.templates.set("tools-index", Handlebars.compile(this.getDefaultToolsIndexTemplate()));
    this.templates.set("models", Handlebars.compile(this.getDefaultModelsTemplate()));
    this.templates.set("cli", Handlebars.compile(this.getDefaultCliTemplate()));
  }

  private getDefaultToolTemplate(): string {
    return `# {{name}}

**Description:** {{description}}

## Input Schema
{{#if inputSchema}}
| Field | Type | Required | Description |
|-------|------|----------|-------------|
{{#each inputSchema}}
| {{field}} | {{type}} | {{#if required}}Yes{{else}}No{{/if}} | {{description}} |
{{/each}}
{{else}}
*No input schema defined*
{{/if}}

## Output Schema
{{#if outputSchema}}
| Field | Type | Required | Description |
|-------|------|----------|-------------|
{{#each outputSchema}}
| {{field}} | {{type}} | {{#if required}}Yes{{else}}No{{/if}} | {{description}} |
{{/each}}
{{else}}
*No output schema defined*
{{/if}}

## Permissions
{{#if permissions}}
{{#each permissions}}
- \`\{{this}}\`
{{/each}}
{{else}}
No special permissions required.
{{/if}}

{{#if examples}}
## Examples
{{#each examples}}
\`\`\`typescript
{{this}}
\`\`\`
{{/each}}
{{/if}}

---

*Generated by Arium Docs Generator*
`;
  }

  private getDefaultToolsIndexTemplate(): string {
    return `# Tools Reference

| Tool | Description | Permissions |
|------|-------------|-------------|
{{#each tools}}
| [{{name}}](./tools/{{name}}.md) | {{description}} | {{#if permissions}}{{#each permissions}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}{{else}}None{{/if}} |
{{/each}}

---

*Generated by Arium Docs Generator*
`;
  }

  private getDefaultModelsTemplate(): string {
    return `# Models Reference

{{#each models}}
## {{name}}

**Provider:** {{provider}}
**Description:** {{description}}

### Configuration
\`\`\`json
{{json config}}
\`\`\`

### Capabilities
{{#each capabilities}}
- {{this}}
{{/each}}

{{/each}}

---

*Generated by Arium Docs Generator*
`;
  }

  private getDefaultCliTemplate(): string {
    return `# CLI Reference

## Commands

{{#each commands}}
### \`arium {{name}}\`

{{description}}

**Usage:**
\`\`\`bash
arium {{name}} {{#each options}}[{{this}}] {{/each}}
\`\`\`

{{#if options}}
**Options:**
{{#each options}}
- \`{{this}}\`: {{description}}
{{/each}}
{{/if}}

{{/each}}

---

*Generated by Arium Docs Generator*
`;
  }
}

export interface SchemaField {
  field: string;
  type: string;
  required: boolean;
  description?: string;
}

export interface ModelInfo {
  name: string;
  provider: string;
  description: string;
  config: Record<string, any>;
  capabilities: string[];
}

export interface CliCommand {
  name: string;
  description: string;
  options?: Array<{
    flags: string;
    description: string;
  }>;
}
